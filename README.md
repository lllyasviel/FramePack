# goan: A Power-User UI for FramePack

Welcome to `goan`, an enhanced user interface designed for creative professionals and power users of FramePack. This project builds upon the brilliant FramePack video generation engine created by lllyasviel (the creator of Fooocus and the Stable Diffusion Forge fork of A1111), exposing its deep functionality through a robust and intuitive interface.

The base FramePack provides a powerful core model. `goan` extends it with a suite of tools designed for serious workflow, experimentation, and reproducibility. If you want to move beyond simple demos and unlock fine-grained control over your video generations, you're in the right place. This UI adds features for batch processing, parameter editing, effortless recipe sharing, and complete workspace management, allowing you to focus on your creative vision.

This document outlines the key features `goan` brings to the FramePack engine.

---

### Functional & UI Control Comparison

Beyond the structure, `goan` introduces significant new functionality and exposes deeper control over the diffusion process.

#### Diffusion Controls (CFG, Guidance Scale)

**Understanding CFG:** Classifier-Free Guidance (CFG) is a critical technique in diffusion models. Think of it as a knob that controls how strongly the model should adhere to your text prompt versus how much creative freedom it has.
* A **low CFG** value allows the model to be more imaginative, potentially straying from the prompt.
* A **high CFG** value forces the model to follow the prompt more strictly, which can sometimes reduce creativity or lead to artifacts if pushed too high.

In this model, there are two main guidance controls:
* `CFG Scale` (`cfg`): The standard guidance scale.
* `Distilled CFG Scale` (`gs`): A specific parameter for the distilled version of the model, which is the primary control used here.

**Comparison:**
* **Base FramePack:** Presented a very simplified interface. Key controls like `CFG Scale` and `CFG Re-Scale` were hidden (`visible=False`), and the `info` text for `Distilled CFG Scale` explicitly said, "Changing this value is not recommended." This was effective for a simple demo but limited experimentation.
* **`goan`:** Exposes all guidance controls for the power user. It introduces the concept of **Variable CFG**, allowing the `Distilled CFG Scale` to change linearly over the course of the generation. This provides advanced control over the video's evolution, letting a user start with high prompt adherence and gradually decrease it, for example.

#### New Functionality: Workspace & Metadata

This entire feature set is new in `goan` and was completely absent in the base FramePack.

* **Drop-in Parameter Loading:** This is the core of the new workflow. You can take a PNG generated by `goan`, drop it into the image input, and the UI will automatically detect the embedded settings. A modal will ask if you want to apply them. This makes sharing and reusing "recipes" effortless.
* **Workspace Management:** Users can now save the *entire state* of the UI—all sliders, text boxes, and checkboxes—to a `.json` file. This "workspace" can be reloaded at any time, which is invaluable for complex projects or for ensuring consistent settings across sessions.
* **Session Persistence & Autosave:** The task queue is automatically saved when the application is closed and reloaded on startup. This prevents the loss of a long list of batched jobs. The UI also attempts to restore its last state after a page refresh.
* **Full Task Queue Control:** `goan` includes a full-featured task queue where you can add, remove, reorder, and *edit* jobs before you start processing. This is a massive improvement over the original's single-task processing model.

### For Developers: A Look Under the Hood

For those interested in the technical evolution, the most significant change is the shift from the base FramePack's single, monolithic script to a modular, package-based architecture in `goan`.

| Aspect | Base FramePack | `goan` |
| :--- | :--- | :--- |
| **File Structure** | A single script containing all logic: model loading, UI layout, and event handlers. | A Python package (`ui/`) with distinct modules for each concern: `layout.py`, `queue.py`, `workspace.py`, `metadata.py`, and `shared_state.py`. |
| **UI Definition** | UI layout is defined directly in the main script using `gr.Blocks()`. | UI is defined in a dedicated `ui/layout.py` file within a `create_ui()` function, which returns a dictionary of all UI components. |
| **State Management** | Relies on global variables (like `stream`) and passes all parameters directly into the main processing function. | Centralized state management via a main `app_state` dictionary for transient UI state and a `ui/shared_state.py` module for global resources like models and threading events. |
| **Event Handling** | All `.click()` and `.change()` events are wired at the bottom of the main script, directly calling local functions. | The main `goan.py` script retrieves UI components from the layout manager and wires them to handler functions imported from the other `ui` modules. |

This modular approach makes the code vastly easier to read, debug, and extend in the future.

### Code Example: A Glimpse at the New Architecture

The difference in philosophy is best illustrated by how a simple button click is handled.

**In Base FramePack:**
A single, long list of inputs is passed directly to a local function within the same script.

```python
# All logic is in one file
ips = [input_image, prompt, n_prompt, seed, ...] 
start_button.click(fn=process, inputs=ips, outputs=[...])

In goan.py (New Architecture):
The UI is built by one module, the handler function lives in another, and the main script connects them.

# In goan.py

# 1. Get UI components from the layout manager
ui_components = layout_manager.create_ui()

# 2. Define inputs using keys from the returned dictionary
task_defining_ui_inputs = [ui_components['input_image_gallery_ui']] + ...

# 3. Wire the button to a function from a *different module* (queue_manager)
ui_components['add_task_button'].click(
    fn=queue_manager.add_or_update_task_in_queue, 
    inputs=[ui_components['app_state']] + task_defining_ui_inputs, 
    outputs=[...]
)
